import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.io.*;

public class Game extends JPanel implements ActionListener {
	
	/* The current game being played. */
	private PlayingField currentgame;
	/* Constructor. Starts an easy feeding game by default. */
	public Game() {
		this.currentgame = new PlayingField("Feeding", 3);
	}
	/* Creates the content pane for the frame. */
	public Container createContentPane() {
		JPanel contentPane = new JPanel();
		contentPane.add(this.currentgame);
		return contentPane;
	/* Creates the game menu. */
	public JMenuBar createMenuBar() {
		JMenuBar menuBar = new JMenuBar();
		
		/* Create top-level ``Game'' menu. */
		JMenu gameMenu = new JMenu("Game");
		/* Create ``New'' sub-menu. */
		JMenu newGame = new JMenu("New");
		/* Create items for ``New'' sub-menu. */
		JMenuItem basicGame = new JMenuItem("Basic game");
		JMenuItem easyFeedingGame = new JMenuItem("Easy feeding game");
		JMenuItem moderateFeedingGame = new JMenuItem("Moderate feeding game");
		JMenuItem hardFeedingGame = new JMenuItem("Hard feeding game");
		/* Create items for main ``Game'' menu. */
		JMenuItem save = new JMenuItem("Save...");
		JMenuItem load = new JMenuItem("Load...");
		JMenuItem quit = new JMenuItem("Quit");
		/* Add the ``Game'' menu to the menu bar. */
		menuBar.add(gameMenu);
		/* Add the ``New'' sub-menu to the ``Game'' menu. */
		gameMenu.add(newGame);
		/* 
		 * Add the basic game option to the ``New'' menu and set up the action
		 * listener.
		 */
		newGame.add(basicGame);
		basicGame.addActionListener(this);
		 * Add the easy feeding game option to the ``New'' menu and set up the 
		 * action listener.
		newGame.add(easyFeedingGame);
		easyFeedingGame.addActionListener(this);
		 * Add the moderate feeding game option to the ``New'' menu and set up 
		 * the action listener.
		newGame.add(moderateFeedingGame);
		moderateFeedingGame.addActionListener(this);
		 * Add the hard feeding game option to the ``New'' menu and set up the 
		newGame.add(hardFeedingGame);
		hardFeedingGame.addActionListener(this);
		 * Add the save option to the ``Game'' menu and set up the  action 
		gameMenu.add(save);
		save.addActionListener(this);
		 * Add the load option to the ``Game'' menu and set up the  action 
		gameMenu.add(load);
		load.addActionListener(this);
		 * Add the quit option to the ``Game'' menu and set up the  action 
		gameMenu.add(quit);
		quit.addActionListener(this);
		return menuBar;
	/*
	 * Controls what happens when an action is detected (a menu item is
	 * selected).
	 */
	public void actionPerformed(ActionEvent e) {
		/* The file to load from or save to. */
		File file;
		/* Cast the source of the ActionEvent into a menu item for selection. */
		JMenuItem source = (JMenuItem)(e.getSource());
		/* Detect which menu item was clicked. */
		if (source.getText().equals("Basic game")) {
			/* Upon selecting a new basic game, create a new basic game. */
			this.currentgame.newGame("Basic", 5);
			
		} else if (source.getText().equals("Easy feeding game")) {
			/* 
			 * Upon selecting an easy feeding game, create a new easy feeding
			 * game.
			 */
			this.currentgame.newGame("Feeding", 3);
		} else if (source.getText().equals("Moderate feeding game")) {
			 * Upon selecting a moderate feeding game, create a new moderate 
			 * feeding game.
			this.currentgame.newGame("Feeding", 4);
		} else if (source.getText().equals("Hard feeding game")) {
			 * Upon selecting a hard feeding game, create a new hard feeding
			currentgame.newGame("Feeding", 10);
		} else if (source.getText().equals("Load...")) {
			/* Pause the game. */
			this.currentgame.stopFeedingRow();
			this.currentgame.pauseTimeLimit();
			this.currentgame.stopTimeLimit();
				
			 * Present the user with a file chooser dialog to select the file
			 * to load.
			file = getInputFile("Choose game to load");
			if (file != null) {
				/* If the user chose a file, load it. */
				this.currentgame.loadGame(file);
			} else {
				/* If a user cancelled loading resume play. */
				this.currentgame.startFeedingRow();
				this.currentgame.resumeTimeLimit();
				this.currentgame.startTimeLimit();
			}
		} else if (source.getText().equals("Save...")) {
			/* If the game is still going on... */
			if (!this.currentgame.isGameOver()) {
				/* Pause the game. */
				this.currentgame.stopFeedingRow();
				this.currentgame.stopTimeLimit();
				this.currentgame.pauseTimeLimit();
				/* 
				 * Present the user with a file chooser dialog to choose where
				 * they want to save to.
				 */
				file = getOutputFile("Choose where to save");
				if (file != null) {
					/* If a file is selected, save to it. */
					this.currentgame.saveGame(file);
					
				}
				/* Resume play. */
				 * Emit a system beep to alert the user that the game cannot
				 * be saved at this time.
				Toolkit.getDefaultToolkit().beep();
		} else if (source.getText().equals("Quit")) {
			/* Quit the game. */
			System.exit(0);
		}
	/* 
	 * Present the user with a file chooser dialog to select a file for input. 
	 * The title of the dialog box is determined by the ``caption'' argument.
	public File getInputFile(String caption) {
		JFileChooser chooser = new JFileChooser();
		chooser.setDialogTitle(caption);
		int openReturnVal = chooser.showOpenDialog(null);
		if (openReturnVal == JFileChooser.APPROVE_OPTION) {
			return chooser.getSelectedFile();
		} else {
			return null;
	 * Present the user with a file chooser dialog to select a file for 
	 * output. The title of the dialog box is determined by the ``caption''
	 * argument.
	public File getOutputFile(String caption) {
		JFileChooser outputdialog = new JFileChooser();
		outputdialog.setDialogTitle(caption);
		int openReturnVal = outputdialog.showSaveDialog(null);
			return outputdialog.getSelectedFile();
	 * Return the size of the game plus some space to take the menu bar into
	 * account.
	public Dimension getGameSize() {
		Dimension d = this.currentgame.getPreferredSize();
		d.setSize(d.getWidth(), d.getHeight() + 55);
		return d;
	/* Create and show the graphical user interface. */
	private static void createAndShowGUI() {
		JFrame frame = new JFrame("My Collapsing Puzzle");
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Game game = new Game();
		frame.setJMenuBar(game.createMenuBar());
		frame.setContentPane(game.createContentPane());
		frame.setSize(game.getGameSize());
		frame.setVisible(true);
	/* Run the game. */
	public static void main(String[] args) {
		javax.swing.SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                createAndShowGUI();
            }
        });
}/*
 * ColourBomb.java		$Date: 2004/03/28 16:28:44 $
 *
 * Paul Mucur (0346349)
 * CMPS1A4Y (Programming - Languages and Software Construction)
 * A class to represent a ``colour bomb'' in the Collapsing Puzzle game. A 
 * colour bomb, when detonated, deletes all blocks of a certain colour from the 
 * game.
 */
 
public class ColourBomb extends Block {
	/* Colour of this bomb. */
	private Color colour;
	/* Accessor method to return the colour of this bomb. */
	public Color getColour() {
		return this.colour;
	/* Constructor. Sets the bomb's colour. */
	public ColourBomb(Color colour) {
		this.colour = colour;
	/* Overridden paintComponent method to display the block as an oval. */
	protected void paintComponent(Graphics g) {
		/* Set the colour of the Graphics object to the colour of the block. */
		g.setColor(this.colour);
		/* Fill an oval with the colour. */
		g.fillOval(0, 0, getWidth(), getHeight());
		 * Cast the Graphics object into a Graphics2D object to paint the 
		 * block.
		Graphics2D g2d = (Graphics2D)g.create();
		/* Dispose of the Graphics2D object. */
		g2d.dispose();
}package com.kurumsaljava.controllers;
import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
im/Users/nazribajuri/BlueOptima/PLDetector/resources/code/test/Java/ColourBomb.javaport javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
 * Servlet implementation class contoller
@WebServlet("/contoller")
public class contoller extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public contoller() {
        super();
        // TODO Auto-generated constructor stub
    }
	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		//response.getWriter().append("Served at: ").append(request.getContextPath());
    RequestDispatcher view = request.getRequestDispatcher("WEB-INF/views/loginform.jsp");
		view.forward(request, response);
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//doGet(request, response);
		String username = request.getParameter("username");
		String password = request.getParameter("password");
		System.out.println("username is: " + username);
		System.out.println("password is: " + password);
	PrintWriter writer = response.getWriter();
		String htmlRespone = "<html><h3>";
		htmlRespone += "username is: " + username + "<br/>";		
		htmlRespone += "password is: " + password + "<br/>";
		htmlRespone += "</h3></html>";
		// return response
		writer.println(htmlRespone);
}
/*
 * Block.java		$Date: 2004/03/28 16:28:44 $
 * An abstract class to represent a single block in the Collapsing Puzzle game.
 * Blocks can be susceptible to gravity and attraction and can be flagged for
 * removal from the game.
abstract class Block extends JComponent {
	/* Determines whether this block is affected by gravity or not. */
	boolean subjectToGravity	= true;
	/* Determines whether this block is affected by attraction or not. */
	boolean subjectToAttraction	= true;
	/* Determines whether this block needs to be removed or not. */
	boolean toBeRemoved			= false;
	 * Accessor method to return whether or not a block is subject to 
	 * gravity.
	public boolean subjectToGravity() {
		return subjectToGravity;
	 * attraction.
	public boolean subjectToAttraction() {
		return subjectToAttraction;
	/* Accessor method to return whether or not a block is to be removed. */
	public boolean toBeRemoved() {
		return toBeRemoved;
	/* When the block is clicked on, flag it for removal. */
	public void click() {
		this.toBeRemoved = true;
	/* Resets a block so that it is no longer set to be removed. */
	public void reset() {
		this.toBeRemoved = false;
}package nigelhenshaw.com.videoapp;
import android.app.Application;
import android.test.ApplicationTestCase;
 * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
public class ApplicationTest extends ApplicationTestCase<Application> {
    public ApplicationTest() {
        super(Application.class);
 * EmptyBlock.java		$Date: 2004/03/28 16:28:44 $
 * A class to represent an empty block; i.e. an empty space in the game.
public class EmptyBlock extends Block {
		/* Do nothing. */
}package cucumber.demo;
public class Hello {
    public String greet(String who, String from) {
        return "Hi, + who + . I'm " + from;
    
    public boolean isFriend(String who) {
        return true;
    public String getPhoneNumber(String who) {
        throw new RuntimeException("NOPE");
        //return "98219458";
 * Grid.java		$Date: 2004/03/30 02:42:49 $
 * A class to represent the game grid using a two-dimensional array of Block
 * objects. This class controls where blocks are, which blocks exist etc. It
 * applies gravity and attraction to the game and also manages what happens
 * when a block is clicked on: it removes clusters, detonates bombs etc. It
 * also feeds new rows to the game and keeps track of the score.
import java.util.*;
public class Grid {
	/* Constants for game state codes. */
	public final static int PLAYING = 2;
	public final static int LOST 	= 1;
	public final static int WON 	= 0;
	/* Game state code. */
	private int gameState = PLAYING;
	/* The playing field as a two-dimensional array of Blocks. */
	private Block[][]	grid;
	/* The feeding row. */
	private Block[]		feedingRow;
	 * The playing field as a two-dimensional array of boolean values, used for
	 * defining clusters of blocks: when a block is checked, its position is
	 * set as ``true'' in the checking grid.
	private boolean[][]	checkingGrid;
	private boolean[][]	detectionCheckingGrid;
	/* The current score in the game. */
	private int			score;
	/* Number of blocks currently detected in a cluster. */
	private int			numberInCluster;
	private int			detectionNumberInCluster;
	/* Type of game. */
	private String		gameType;
	/* Difficulty level of the game. */
	private int			difficulty	= 3;
	/* Random number generator, used for creating random rows of blocks. */
	private Random generator = new Random();
	/* Accessor method to return the type of game. */
	public String getGameType() {
		return gameType;
	/* Accessor method to return the number of rows in the grid. */
	public int getRows() {
		return grid.length;
	/* Accessor method to return the current score. */
	public int getScore() {
		return score;
	/* Accessor method to return the number of columns in the grid. */
	public int getColumns() {
		return grid[0].length;
	/* Accessor method to return a single block from the grid. */
	public Block getBlock(int row, int column) {
		return grid[row][column];
	public Block getFeedingRowBlock(int column) {
		return feedingRow[column];
	/* Accessor method to return the difficulty level of the game. */
	public int getDifficulty() {
		return difficulty;
	/* Accessor method to set the difficulty level of the game. */
	public void setDifficulty(int difficulty) {
		this.difficulty = difficulty;
	/* Returns the game state code. */
	public int getGameState() {
		return this.gameState;
	/* Returns the type of game. */
	public void setGameType(String gameType) {
		this.gameType = gameType;
	/* Set the game state code. */
	public void setGameState(int gameState) {
		this.gameState = gameState;
	/* Set the game score. */
	public void setScore(int score) {
		this.score = score;
	 * Constructor. Reads in grid file and turns it into two-dimensional Block
	 * array.
	public Grid(File gridFile) {
		try {
			/* BufferedReader to read in one line of the grid file at a time. */
			BufferedReader	reader	
					= new BufferedReader(new FileReader(gridFile));
			/* StringTokenizer to tokenize each line at a time. */
			StringTokenizer tokenizer;
			/* String containing current line being read. */
			String			line 		= reader.readLine();
			/* String containing current token being read. */
			String 			token 		= new String();
			/* Flag to indicate that a line is a comment. */
			boolean 		comment		= false;
			/* Current row of the grid. */
			int 			row 		= -1;
			/* Current column of the grid. */
			int 			column 		= 0;
			/* Number of rows in the grid file as indicated by "Rows: ". */
			int 			rows 		= 0;
			/* Number of columns in the grid file. */
			int 			columns 	= 0;
			/* Flag to indicate whether the grid is being read in or not. */
			boolean 		readGrid 	= false;
			/* Flag to indicate whether or not the grid has been initialised. */
			boolean			gridCreated	= false;
			/* Read each line of the grid file until there are no more lines. */
			while (line != null) {
				 * If reading the grid, increment the row counter and reset 
				 * the column counter. 
				if (readGrid) {
					row++;
					column = 0;
				/* Tokenize the current line to parse it. */
				tokenizer = new StringTokenizer(line);
				/* Traverse each line in tokens. */
				while (tokenizer.hasMoreTokens() && !comment) {
					token = tokenizer.nextToken();
					/* Detect whether or not a line is a comment. */
					if (token.equals("%")) {
						comment = true;
					} else {
						
						/* Create grid. */
						if (rows > 0 && columns > 0 && !gridCreated) {
							this.grid = new Block[rows][columns];
							this.checkingGrid = new boolean[rows][columns];
							
							if (this.gameType.equals("Feeding")) {
								this.feedingRow = new Block[columns];
								emptyFeedingRow();
							}
							gridCreated = true;
						}
						/* If the readGrid flag is true, parse the grid. */
						if (readGrid) {
							if (token.equals("e")) {
								/* 
								 * If the character is an ``e'', insert an empty 
								 * block.
								 */
								if (row < this.grid.length) {
									this.grid[row][column] = new EmptyBlock();
								} else if (this.gameType.equals("Feeding")) {
									this.feedingRow[column] 
											= new EmptyBlock();
								}
								/* Increment the column counter. */
								column++;
								
							} else if (token.equals("b")) {
								 * If the character is an ``b'', insert a blue 
									this.grid[row][column] 
											= new ColouredBlock(Color.blue);
							} else if (token.equals("r")) {
								 * If the character is an ``r'', insert a red 
										= new ColouredBlock(Color.red);
											= new ColouredBlock(Color.red);
							} else if (token.equals("g")) {
								 * If the character is a ``g'', insert a green 
											= new ColouredBlock(Color.green);
										
							} else if (token.equals("y")) {
								 * If the character is a ``y'', insert a yellow 
										= new ColouredBlock(Color.yellow);
											= new ColouredBlock(Color.yellow);
							} else if (token.equals("w")) {
								 * If the character is a ``w'', insert a white 
										= new ColouredBlock(Color.white);
											= new ColouredBlock(Color.white);
							} else if (token.equals("p")) {
								 * If the character is a ``p'', insert a
								 * platform block.
									this.grid[row][column] = new Platform();
									this.feedingRow[column] = new Platform();
							} else if (token.equals("i")) {
								 * If the character is an ``i'', insert an
								 * indestructible block.
										= new IndestructibleBlock();
											= new IndestructibleBlock();
							} else if (token.equals("B")) {
								 * If the character is a ``B'', insert a blue 
								 * bomb.
										= new ColourBomb(Color.blue);
											= new ColourBomb(Color.blue);
							} else if (token.equals("G")) {
								 * If the character is a ``G'', insert a green 
										= new ColourBomb(Color.green);
											= new ColourBomb(Color.green);
							} else if (token.equals("R")) {
								 * If the character is a ``R'', insert a red 
										= new ColourBomb(Color.red);
											= new ColourBomb(Color.red);
							} else if (token.equals("Y")) {
								 * If the character is a ``Y'', insert a yellow 
										= new ColourBomb(Color.yellow);
											= new ColourBomb(Color.yellow);
							} else if (token.equals("W")) {
								 * If the character is a ``W'', insert a white 
										= new ColourBomb(Color.white);
											= new ColourBomb(Color.white);
							} else if (token.equals("S")) {
								 * If the character is a ``S'', insert a super 
										= new SuperBomb();
									this.feedingRow[column] = new SuperBomb();
						/* Parse type, rows and columns data. */
						if (token.equals("Type:") 
								&& tokenizer.hasMoreTokens()) {
							/* Set token to type. */
							token = tokenizer.nextToken();
							/* Set game type. */
							this.gameType = token;
						} else if (token.equals("Rows:") 
							/* Set token to number of rows. */
							/* Set number of rows. */
							rows = Integer.parseInt(token);
						} else if (token.equals("Columns:") 
							/* Set token to number of columns. */
							/* Set number of columns. */
							columns = Integer.parseInt(token);
						} else if (token.equals("Difficulty:") 
							/* Set token to the difficulty level. */
							/* Set the difficulty level. */
							setDifficulty(Integer.parseInt(token));
						} else if (token.equals("Score:") 
							/* Set token to the score. */
							setScore(Integer.parseInt(token));
						} else if (token.equals("Begin")) {
							/* Start reading the grid. */
							readGrid = true;
					}
				/* Read in the next line. */
				line = reader.readLine();
				/* Reset comment flag. */
				comment = false;
		} catch (FileNotFoundException fnf) {
			System.out.println(gridFile.getName() + " was not found.");
		} catch (IOException io) {
			System.out.println("An input/output exception has occured.");
	/* Constructor. Creates a new game with the set difficulty. */
	public Grid(String gameType, int difficulty) {
		/* Create grids. */
		this.grid = new Block[16][12];
		this.checkingGrid = new boolean[16][12];
		if (gameType.equals("Feeding")) {
			this.feedingRow = new Block[12];
			emptyFeedingRow();
		/* Set game type and difficulty. */
		setGameType(gameType);
		setDifficulty(difficulty);
		/* Traverse each row in the grid. */
		for (int row = 0; row < this.grid.length; row++) {
			/* Traverse each column in the row. */
			for (int column = 0; column < this.grid[row].length; column++) {
				 * Depending on the difficulty, fill the bottom few rows of
				 * the grid.
				if (row >= (grid.length - getDifficulty())) {
					this.grid[row][column] = randomBlock();
				} else {
					this.grid[row][column] = new EmptyBlock();
	/* Save the game to a file. */
	public void saveGame(File gridFile) {
			BufferedWriter	output 	= new BufferedWriter(
					new FileWriter(gridFile));
			/* Write out the game type, number of rows and number of columns. */
			output.write("Type: " + getGameType() + "\n");
			output.write("Rows: " + getRows() + "\n");
			output.write("Columns: " + getColumns() + "\n");
			output.write("Difficulty: " + getDifficulty() + "\n");
			output.write("Score: " + getScore() + "\n");
			/* Begin writing the blocks in the grid. */
			output.write("Begin\n");
			/* Copy, one character at a time, from input to output. */
			/* Traverse each row in the grid. */
			for (int row = 0; row < this.grid.length; row++) {
				/* Traverse each column in the row. */
				for (int column = 0; column < this.grid[row].length; column++) {
					output.write(parseIntoSymbol(this.grid[row][column]));
				/* Write out a new line after every row. */
				output.write("\n");
			/* If this is a feeding game, write out the feeding row too. */
			if (getGameType().equals("Feeding")) {
				for (int column = 0; column < this.feedingRow.length; 
						column++) {
					output.write(parseIntoSymbol(this.feedingRow[column]));
				/* Output a new line. */
			/* Write out ``End'' to signal the end of the grid. */
			output.write("End\n");
			output.flush();
			System.out.println("Error, file not found.");
			System.out.println("Error, input/output exception has occured.");
	/* Parses a block and returns its symbol for output. */
	public String parseIntoSymbol(Block blockToParse) {
		/* Symbol. */
		String symbol = new String();
		/* Variable to cast coloured blocks into. */
		ColouredBlock	block;
		/* Variable to cast colour bombs into. */
		ColourBomb		bomb;
		if (blockToParse.getClass().getName().
				equals("EmptyBlock")) {
			/* If the block is an empty block, write out ``e''. */
			symbol = "e ";
		} else if (blockToParse.getClass().getName().
				equals("ColouredBlock")) {
			 * If the block is a coloured block, determine its 
			 * colour.
			block = (ColouredBlock)blockToParse;
			if (block.getColour().equals(Color.blue)) {
				/* If the block is blue, write out ``b''. */
				symbol = "b ";
			} else if (block.getColour().equals(Color.red)) {
				/* If the block is red, write out ``r''. */
				symbol = "r ";
			} else if (block.getColour().equals(Color.green)) {
				/* If the block is green, write out ``g''. */
				symbol = "g ";
			} else if (block.getColour().equals(Color.yellow)) {
				/* If the block is yellow, write out ``y''. */
				symbol = "y ";
			} else if (block.getColour().equals(Color.white)) {
				/* If the block is white, write out ``w''. */
				symbol = "w ";
				equals("Platform")) {
			/* If the block is a platform block, write out ``p''. */
			symbol = "p ";
				equals("IndestructibleBlock")) {
			/*
			 * If the block is an indestructible block, write out 
			 * ``i''.
			symbol = "i ";
				equals("SuperBomb")) {
			/* If the block is a super bomb, write out ``S''. */
			symbol = "S ";
				equals("ColourBomb")) {
			 * If the block is a colour bomb, determine its 
			 * colour. 
			bomb = (ColourBomb)blockToParse;
			if (bomb.getColour().equals(Color.blue)) {
				/* If the block is blue, write out ``B''. */
				symbol = "B ";
			} else if (bomb.getColour().equals(Color.red)) {
				/* If the block is red, write out ``R''. */
				symbol = "R ";
			} else if (bomb.getColour().equals(Color.green)) {
				/* If the block is green, write out ``G''. */
				symbol = "G ";
			} else if (bomb.getColour().equals(Color.yellow)) {
				/* If the block is yellow, write out ``Y''. */
				symbol = "Y ";
			} else if (bomb.getColour().equals(Color.white)) {
				/* If the block is white, write out ``W''. */
				symbol = "W ";
		return symbol;
	 * Update the grid: remove blocks when neccessary, apply gravity, 
	 * attraction, etc. 
	public void updateGrid() {
		for (int row = (grid.length - 1); row >= 0; row--) {
			for (int column = (grid[row].length - 1); column >= 0; column--) {
				 * For each block, check if it needs removing and apply
				 * attraction to the whole grid.
				checkForRemoval(row, column);
				applyAttraction();
		}	
				applyGravity(row, column);
		/* If the game type is basic, check whether the game is over yet. */
		if (getGameType().equals("Basic")) {
			/* If there are no more possible clusters left... */
			if (numberOfClustersInGrid() < 1) {
				if (numberOfBlocksInGrid() < 1) {
					/* If there are no blocks, the game is won. */
					setGameState(WON);
					/* If there are some blocks left, the game is lost. */
					setGameState(LOST);
	/* Returns the number of coloured blocks currently in the grid. */
	private int numberOfBlocksInGrid() {
		/* The number of blocks currently found in the grid. */
		int numberOfBlocksInGrid = 0;
				 * If the current block is a coloured block, increment the
				 * counter.
				if (this.grid[row][column].getClass().getName().
						equals("ColouredBlock")) {
					numberOfBlocksInGrid++;
		return numberOfBlocksInGrid;
	 * Return a random coloured block based on the difficulty setting of the 
	 * game.
	private ColouredBlock randomBlock() {
		int				randomBlock;
		ColouredBlock	blockToReturn = new ColouredBlock(Color.red);
		 * Set up the range of the random number generator based on the 
		 * difficulty setting.
		if (getDifficulty() > 4) {
			randomBlock = generator.nextInt(5);
		} else if (getDifficulty() > 3) {
			randomBlock = generator.nextInt(4);
			randomBlock = generator.nextInt(3);
		/* Choose which colour block to return based on the random number. */
		switch (randomBlock) {
			case 0:
				blockToReturn = new ColouredBlock(Color.red);
				break;
			case 1:
				blockToReturn = new ColouredBlock(Color.blue);
			case 2:
				blockToReturn = new ColouredBlock(Color.green);
			case 3:
				blockToReturn = new ColouredBlock(Color.white);
			case 4:
				blockToReturn = new ColouredBlock(Color.yellow);
		return blockToReturn;
	/* Return the current number of different coloured blocks in the grid. */
	public int numberOfColoursInGrid() {
		/* Use an array list to store the different colours. */
		ArrayList colours = new ArrayList();
		/* Holder for the current block to be cast into. */
		ColouredBlock block;
				/* If the current block is a coloured block. */
					/* Cast the block into a coloured block. */
					block = (ColouredBlock)this.grid[row][column];
					/* If the colour is not already in the list, add it. */
					if (colours.indexOf(block.getColour()) == -1) {
						colours.add(block.getColour());
		return colours.size();
	 * Check the current block to see if it needs to be removed, if so, see
	 * if it is part of a cluster in which case, remove the whole cluster
	 * otherwise reset the block and beep to warn the user.
	private void checkForRemoval(int row, int column) {
		/* If a block in the grid is marked to be removed... */
		if (this.grid[row][column].toBeRemoved()) {
			/* If the block to be removed is a coloured block... */
			if (this.grid[row][column].getClass().getName().
					equals("ColouredBlock")) {
				this.numberInCluster = 1;
				this.checkingGrid[row][column] = true;
				/* Remove blocks of the same colour around it. */
				removeClusterFrom(row, column);
				/* Remove the central block itself if a cluster was found. */
				if (this.numberInCluster > 2) {
					removeBlockAt(row, column);
					/* If the block was not part of a cluster, reset it. */
					this.grid[row][column].reset();
					/* 
					 * Emit a system beep to alert the user that this block
					 * cannot be removed.
					 */
					Toolkit.getDefaultToolkit().beep();
				/* Give bonus points for removing a cluster. */
				if (this.numberInCluster > 10 && this.numberInCluster < 25) {
					score = score + (150 * numberOfColoursInGrid());
				} else if (this.numberInCluster > 24 
						&& this.numberInCluster < 79) {
					score = score + (500 * numberOfColoursInGrid());
				} else if (this.numberInCluster > 78 
						&& this.numberInCluster < 181) {
					score = score + (1500 * numberOfColoursInGrid());
				/* Reset variables changed by detecting clusters. */
				this.numberInCluster = 0;
				this.checkingGrid = new boolean[getRows()][getColumns()];
			} else if (this.grid[row][column].getClass().getName().
					equals("ColourBomb")) {
				/* If the block is a colour bomb... */
				ColourBomb colourbomb = (ColourBomb)this.grid[row][column];
				/* Remove all of the designated colour. */
				removeAllOfColour(colourbomb.getColour());
				/* Remove the block itself. */
				removeBlockAt(row, column);
					equals("SuperBomb")) {
				/* If the block is a super bomb...*/
				SuperBomb superbomb = (SuperBomb)this.grid[row][column];
				int range 					= superbomb.getRange();
				int damageAreaCornerRow 	= row - range;
				int damageAreaCornerColumn 	= column - range;
				for (int i = damageAreaCornerRow; i 
						< (damageAreaCornerRow + ((range * 2) + 1)); i++) {
					for (int j = damageAreaCornerColumn; j 
							< (damageAreaCornerColumn + ((range * 2) + 1)); 
							j++) {
						if (i >= 0 && i < getRows() && j >= 0 
								&& j < getColumns()) {
							removeBlockAt(i, j, false);
	/* Remove all blocks of a certain colour from the grid. */
	private void removeAllOfColour(Color colour) {
					ColouredBlock block = (ColouredBlock)this.grid[row][column];
					if (block.getColour().equals(colour)) {
						removeBlockAt(row, column);
	/* Traverse grid and apply gravity where needed. */
	private void applyGravity(int row, int column) {
		int searchRow = row;
		if (this.grid[row][column].getClass().getName().equals("EmptyBlock")) {
			while ((searchRow - 1) >= 0 
					&& this.grid[searchRow][column].getClass().getName().
							equals("EmptyBlock")) {
				searchRow--;
			if (searchRow >= 0 && this.grid[searchRow][column].
					subjectToGravity()) {
				this.grid[row][column] = this.grid[searchRow][column];
				this.grid[searchRow][column] = new EmptyBlock();
	/* Apply attraction to the entire grid. */
	private void applyAttraction() {
		/* Counter for how many empty blocks have been found in a column. */
		int numberOfEmptyBlocks = 0;
		/* Current empty column. */
		int emptyColumn;
		/* Used to cast the column number into an int value. */
		Integer holder;
		/* Array list to hold each empty column found. */
		ArrayList emptyColumns = new ArrayList();
		/* Traverse each column in the grid. */
		for (int column = 0; column < this.grid[0].length; column++) {
			/* Traverse each row in the column. */
				/* If the current block is empty, increment the counter. */
				if (grid[row][column].getClass().getName().
						equals("EmptyBlock")) {
					numberOfEmptyBlocks++;
			/* If the entire column is empty, add the column to the list. */
			if (numberOfEmptyBlocks == grid.length) {
				emptyColumns.add(new Integer(column));
			/* Reset the number of empty blocks in the column. */
			numberOfEmptyBlocks = 0;
		/* Go through each empty column in the list. */
		for (int i = 0; i < emptyColumns.size(); i++) {
			/* Cast the column into an int. */
			holder = (Integer)emptyColumns.get(i);
			emptyColumn = holder.intValue();
			if ((this.grid[0].length / 2) >= emptyColumn) {
				 * If the column falls on the left side of the grid, move blocks
				 * right.
				moveBlocksRight(emptyColumn);
			} else if ((this.grid[0].length / 2) < emptyColumn) {
				 * If the column falls on the right side of the grid, move
				 * blocks left.
				moveBlocksLeft(emptyColumn);
	/* Move each block in a column right. */
	private void moveBlocksRight(int column) {
		for (int row = (this.grid.length - 1); row >= 0; row--) {
			if (column - 1 >= 0) {
					if (!this.grid[row][column-1].getClass().getName().
						if (this.grid[row][column-1].subjectToAttraction()) {
							this.grid[row][column] = this.grid[row][column-1];
							this.grid[row][column-1] = new EmptyBlock();
	/* Move each block in a column left. */
	private void moveBlocksLeft(int column) {
			if (column + 1 < getColumns()) {
					if (!this.grid[row][column+1].getClass().getName().
						if (this.grid[row][column+1].subjectToAttraction()) {
							this.grid[row][column] = this.grid[row][column+1];
							this.grid[row][column+1] = new EmptyBlock();
	/* Removes block at given co-ordinates and increments score accordingly. */
	private void removeBlockAt(int row, int column) {	
		if (this.grid[row][column].getClass().getName().
			this.score = this.score + 5;
		this.grid[row][column] = new EmptyBlock();
	private void removeBlockAt(int row, int column, boolean score) {	
		if (score) {
				this.score = this.score + 5;
	/* Returns the number of clusters currently in the grid. */
	public int numberOfClustersInGrid() {
		/* Set up detection grid. */
		this.detectionCheckingGrid = new boolean[getRows()][getColumns()];
		/* The number of clusters in the grid. */
		int numberOfClusters = 0;
					this.detectionNumberInCluster = 1;
					this.detectionCheckingGrid[row][column] = true;
					 * If the block is part of a cluster, increment the 
					 * counter. 
					if (blockIsACluster(row, column)) {
						numberOfClusters++;
						/* Reset the counter. */
						this.detectionNumberInCluster = 0;
		/* Reset the checking grid. */
		return numberOfClusters;
	 * Detects a cluster of blocks and returns true if one is found from the
	 * current block.
	private boolean blockIsACluster(int row, int column) {
		ColouredBlock	centreBlock = (ColouredBlock)this.grid[row][column];
		Color			colour		= centreBlock.getColour();
		/* Check block to the right. */
		if (column+1 < this.grid[column].length) {
			if (this.grid[row][column+1].getClass().getName().
				ColouredBlock rightBlock 
						= (ColouredBlock)this.grid[row][column+1];
				/*
				 * If the block is the right colour and has not been checked 
				 * before... 
				if (rightBlock.getColour().equals(colour) 
						&& !this.detectionCheckingGrid[row][column+1]) {
					/* Mark as checked. */
					this.detectionCheckingGrid[row][column+1] = true;
					/* Increment the counter. */
					this.detectionNumberInCluster++;
					/* Check from this point onwards. */
					blockIsACluster(row, column+1);
		/* Check block to the left. */
		if (column-1 >= 0) {
			if (this.grid[row][column-1].getClass().getName().
				ColouredBlock	leftBlock 
						= (ColouredBlock)this.grid[row][column-1];
				if (leftBlock.getColour().equals(colour) 
						&& !this.detectionCheckingGrid[row][column-1]) {
					this.detectionCheckingGrid[row][column-1] = true;
					blockIsACluster(row, column-1);
		/* Check block above. */
		if (row-1 >= 0) {
			if (this.grid[row-1][column].getClass().getName().
				ColouredBlock	aboveBlock 
						= (ColouredBlock)this.grid[row-1][column];
				if (aboveBlock.getColour().equals(colour) 
						&& !this.detectionCheckingGrid[row-1][column]) {
					this.detectionCheckingGrid[row-1][column] = true;
					blockIsACluster(row-1, column);
		/* Check block below. */
		if (row+1 < grid.length) {
			if (this.grid[row+1][column].getClass().getName().
				ColouredBlock	belowBlock 
						= (ColouredBlock)this.grid[row+1][column];
				if (belowBlock.getColour().equals(colour) 
						&& !this.detectionCheckingGrid[row+1][column]) {
					this.detectionCheckingGrid[row+1][column] = true;
					blockIsACluster(row+1, column);
		/* If more than two blocks were detected as connected, return true. */
		if (this.detectionNumberInCluster >= 3) {
			return true;
			return false;
	 * Detects and removes a cluster of blocks of the same colour if three 
	 * or more connected ones exist.
	private void removeClusterFrom(int row, int column) {
		boolean deleteBlockToRight		= false;
		boolean deleteBlockToLeft		= false;
		boolean deleteBlockAbove		= false;
		boolean deleteBlockBelow		= false;
		boolean deleteSuperBombToRight	= false;
		boolean deleteSuperBombToLeft	= false;
		boolean deleteSuperBombAbove	= false;
		boolean deleteSuperBombBelow	= false;
		ColouredBlock	centreBlock = (ColouredBlock)grid[row][column];
						&& !this.checkingGrid[row][column+1]) {
					this.checkingGrid[row][column+1] = true;
					this.numberInCluster++;
					removeClusterFrom(row, column+1);
					deleteBlockToRight = true;
			} else if (this.grid[row][column+1].getClass().getName().
				deleteSuperBombToRight = true;
						&& !this.checkingGrid[row][column-1]) {
					this.checkingGrid[row][column-1] = true;
					removeClusterFrom(row, column-1);
					deleteBlockToLeft = true;
			} else if (this.grid[row][column-1].getClass().getName().
				deleteSuperBombToLeft = true;
						&& !this.checkingGrid[row-1][column]) {
					this.checkingGrid[row-1][column] = true;
					removeClusterFrom(row-1, column);
					deleteBlockAbove = true;
			} else if (this.grid[row-1][column].getClass().getName().
				deleteSuperBombAbove = true;
		if (row+1 < this.grid.length) {
						&& !this.checkingGrid[row+1][column]) {
					this.checkingGrid[row+1][column] = true;
					removeClusterFrom(row+1, column);
					deleteBlockBelow = true;
			} else if (this.grid[row+1][column].getClass().getName().
				deleteSuperBombBelow = true;
		/* Delete blocks as necessary. */
		if (this.numberInCluster > 2) {
			if (deleteBlockToRight || deleteSuperBombToRight) {
				removeBlockAt(row, column+1);
			if (deleteBlockToLeft || deleteSuperBombToLeft) {
				removeBlockAt(row, column-1);
			if (deleteBlockAbove || deleteSuperBombAbove) {
				removeBlockAt(row-1, column);
			if (deleteBlockBelow || deleteSuperBombBelow) {
				removeBlockAt(row+1, column);
	 * Add a new random block to the feeding row; if the feeding row is full
	 * add the feeding row to the playing field. Returns boolean value to
	 * indicate whether a new row has been added or not (so that the playing
	 * field can redraw only when necessary).
	public boolean addToFeedingRow() {
		/* Index of the feeding row. */
		int i = 0;
		/* Traverse to the first empty space in the feeding row. */
		while (i < this.feedingRow.length 
				&& !this.feedingRow[i].getClass().getName().
					equals("EmptyBlock")) {
			i++;
		if (i >= feedingRow.length) {
			 * If the feeding row is full, add the feeding row to the playing
			 * field.
			addFeedingRowToGrid();
			/* Empty the feeding row. */
			/* Add a random block to the feeding row. */
			this.feedingRow[i] = randomBlock();
	/* Empty the feeding row. */
	private void emptyFeedingRow() {
		for (int column = 0; column < this.feedingRow.length; column++) {
			feedingRow[column] = new EmptyBlock();
	/* Add the feeding row to the playing field. */
	public void addFeedingRowToGrid() {
				/* If the playing field is full the game is lost. */
				if (row == 0 && !this.grid[row][column].getClass().getName().
				/* Move all blocks up one. */
				if (row-1 >= 0) {
					this.grid[row-1][column] = this.grid[row][column];
				/* Add the feeding row to the grid. */
				if (row == (this.grid.length - 1)) {
					this.grid[row][column] = this.feedingRow[column];
 * IndestructibleBlock.java		$Date: 2004/03/28 16:28:44 $
 * A class to represent an indestructible block.
public class IndestructibleBlock extends Block {
	/* Overridden paintComponent method to display the block as a 3D square. */
		g.setColor(Color.lightGray);
		/* Fill a 3D raised rectangle with the colour. */
		g.fill3DRect(0, 0, getWidth(), getHeight(), true);
 * ColouredBlock.java		$Date: 2004/03/28 16:28:44 $
 * A class to represent a single coloured block in the Collapsing Puzzle game.
public class ColouredBlock extends Block {
	/* Colour of this block. */
	/* Constructor. */
	public ColouredBlock(Color colour) {
	/* Accessor method to return colour of this block. */
